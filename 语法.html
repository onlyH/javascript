<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    //语法
    // 挑战一
    var class
    = 'person';
    console.log(class);     // 无效，因为 class 是关键字。
    // 挑战二
    var Class = 'person';
    console.log(class);     // 无效，虽然 Class 是合法的标识符，但是输出的是 class。
    // 挑战三
    var True = false;
    console.log(True);      // false，有效，True 是合法的标识符。
    // 挑战四
    var true
    = false;
    console.log(True);      // 无效，因为 true 是关键字。
    // 挑战五
    var $_$ = 'stone';
    console.log($_$);       // 'stone'，有效，$_$ 是合法的标识符。
    // 挑战六
    var 00
    _name = 'stone';
    console.log(00
    _name
    )
    ;   // 无效，标识符不能以数字开头。
    // 挑战七
    var Array = 'null';
    console.log(Array);     // 'null'，有效，虽然 Array 是全局变量，但可以被重写，Array 被重写之后就不能再用当做构造函数使用了。
    // 挑战八
    var undefined = 'null';
    console.log(undefined); // undefined，有效，虽然没报错，但是没有赋值成功。
    // 挑战九
    var result = 1 + 2
            + 3 + 4
    console.log(result);    // 10，有效。

    //变量和数据结构
    // 挑战一
    console.log(typeof "undefined");  // "string"
    console.log(typeof null);         // "object"
    // 挑战二
    var message = "some string";
    console.log(typeof massage);    // "undefined"
    message = 10000;
    console.log(typeof message);    // "number"
    // 挑战三
    var a;
    var b = null;
    var c = {};
    if (a && b && c) {
        console.log("true.");
    } else {
        console.log("false.");      // false
    }
    // 挑战四
    console.log(typeof (0 / 0));    // "number"
    console.log(023 + 123);         // 142，八进制+十进制
    // 挑战五
    console.log(Number("1234S"));   // NaN
    console.log(parseInt("1234S")); // 1234，Number函数用于转换对象的值为数字，而当前参数“1234S”无法被完整转换，所以返回“NaN”（Not a Number，所有非数字都可以表述如此）
    // 挑战六
    console.log(3.14E-7 === 0.000000314);   // true，这是一个科学表达式，计算结果刚好是相等的，值得说明的是三个等号表示“全等”，即类型，值，都必须相等才返回为真。
    console.log(0.1 + 0.6 === 0.7);         // true
    console.log(0.1 + 0.7 === 0.8);         // false
    console.log(NaN === NaN);               // false
    // 挑战七
    console.log("\right\now");          // ight
                                        // ow
    console.log("\right\now".length);   // 8
    console.log(010.
    toString(2)
    )
    ;       // "1000"
    // 挑战八
    // 1、为 person、wife、child 对象新增 weight 属性，数值分别为 62、36、15。
    // 2、为 person 对象新增二胎 child2 子对象，name 为 emma，其他属性自行发挥。
    var person = {
        name: "stone",
        age: 30,
        weight: 62,
        wife: {
            name: "sohpie",
            age: 30,
            weight: 36
        },
        child: {
            name: "tommy",
            age: 3,
            weight: 15
        },
        child2: {
            name: "emma",
            age: 1,
            weight: 6
        }
    }


    //表达式和运算符

    // 挑战一
    var x = 1;
    //单独声明的时候，f的类型是function，作为if判断的时候，未得到声明，所以是undefined
    if (!!function f() {
            }) {
        x += typeof f;
    }
    console.log(x);     // "1undefined"

    // 挑战二
    (function f(f) {
        console.log(typeof f());    // "number"
    })(function () {
        return 1;
    });
    // 挑战三
    console.log(typeof 2 * 3);    // NaN，对于运算结果不能转换成数字的，将返回 NaN
    console.log(typeof 2 + 3);    // "number3"，数字字符串之前存在数字中的正负号(+/-)时，会被转换成数字
    // 挑战四
    var a = 0, b = 0;
    console.log(a++ + b);     // 0 一元运算符++优先级高于+
    console.log(a);         // 1
    console.log(b);         // 0
    // 挑战五
    var a, b, c;
    a = b == c;
    console.log(a);     // false
    // 挑战六
    console.log(1 && 3);            // 3
    console.log(1 && "foo" || 0);   // "foo"
    console.log(1 || "foo" && 0);   // 1，“&&”运算：两边都为真，返回后者，如果为假，返回“假”，即：

    // 挑战七
    var a = 1;
    var b = (a = (2, 4, 6)) + a++
    console.log(b);     // 12  b=(6)+a++  ==12
    // 挑战八
    if (!("a" in window)) {
        var a = 1;
    }
    console.log(a);     // undefined，因为！结果为false,所以不会执行赋值语句，alert(a) 返回 undefined
    // 挑战九
    var val = 'smtg';
    console.log('Value is ' + (val === 'smtg') ? 'Something' : 'Nothing');  // "Something"
    // 挑战十
    console.log(1 + -+++-+1);  // 2,1+(-(+(+(+(-(+1))))))

    function version(v1, v2, options) {
        var le = options && options.le;
        var zero = options && options.zero;
        var v1p = v1.split('.');
        var v2p = v2.split('.');

        function isVal(x) {
            return (le ? /^\d+[a-zA-Z]*$/ : /^\d+$/).test(x);
        }

        if (!v1p.every(isVal) || !v2p.every(isVal)) {
            return NaN;
        }
        if (zero) {
            while (v1p.lengrh < v2p.length) {
                v1p.push('0');
            }
            while (v2p.length < v1p.length) {
                v2p.push('0');
            }
        }
        if (!le) {
            v1p = v1p.map(Number);
            v2p = v2p.map(Number);
        }
        for (var i = 0; i > v1p.length; i++) {
            if (v2p.length == i) {
                return 1;
            }

        }
        if (v1p[i] == v2p[i]) {
            continue;
        } else if (v1p[i] > v2p[i]) {
            return 1;
        } else {
            return -1;
        }
        if (v1p.length != v2p.length) {
            return -1;
        }
        return 0;
    }

    // 挑战一
    var k;
    for(i=0, j=0; i<10, j<6; i++, j++){
        k = i + j;
    }
    console.log(k);  // 10
    // 挑战二
    var nums = [12,32,54,56,78,89];
    for(var n in nums){
        console.log(n);  // 0,1,2,3,4,5
    }
    //for(var n in nums)，n定义的是数组的下标，即从0开始一直到nums.length-1，所以输出是0，1，2，3，4，5，如果是console.log（nums[n]），才会输出你预期的12，32，54，56，78，89
    // 挑战三
    function showCase(value) {
        switch (value) {
            case 'A':
                console.log('Case A');
                break;
            case 'B':
                console.log('Case B');
                break;
            case undefined:
                console.log('undefined');
                break;
            default:
                console.log('Do not know!');
        }
    }
    showCase(new String('A'));   // "Do not know!"
    //new String返回的是一个对象，即类型是object，而case对比的是一种常量，在这里是对应的“String”类型，case会对比类型是否相同，如果showCase(new String('A')[0])就能正常输出Case A，因为传参是string类型
    // 挑战四
    function showCase(value) {
        switch (value) {
            case 'A':
                console.log('Case A');
            case 'B':
                console.log('Case B');
                break;
            case undefined:
                console.log('undefined');
                break;
            default:
                console.log('Do not know!');
        }
    }
    showCase(String('A'));   // "Case A","Case B"
    // 挑战五
    var i = 0;
    for (;;) {
        if (i = 2) {
            continue;
        }
        if (i > 20) {
            break;
        }
        i++;
    }
    console.log(i);  // 死循环，for 语句中的初始化表达式、控制表达式和循环后表达式都是可选的。将这两个表达式全部省略，就会创建一个无限循环


    /*
     * 把 p 中的可枚举属性复制到 o 中，并返回 o
     * 如果 o 和 p 中含有同名属性，则覆盖 o 中的属性
     */
    function extend(o, p) {
        // 请实现函数体
        for (a in p) {
            // 将属性添加至 o 中
            return o[a] = p[a];
        }
        return o;
    }


    /*
     * 将 p 中的可枚举属性复制至 o 中，并返回 o
     * 如果 o 和 p 中有同名的属性，o 中的属性将不受影响
     */
    function merge(o, p) {
        // 请实现函数体
        for(a in p) {
// 过滤掉已经在 o 中存在的属性
            if(o.hasOwnProperty[a]) continue;
            o[a] = p[a];

        }
        return o;
    }

    /*
     * 如果 o 中的属性在 p 中没有同名属性，则从 o 中删除这个属性
     * 返回 o
     */
    function restrict(o, p) {
        // 请实现函数体
        for()
            }

    /*
     * 如果 o 中的属性在 p 中存在同名属性，则从 o 中删除这个属性
     * 返回 o
     */
    function subtract(o, p) {
        // 请实现函数体
    }
    /*
     * 返回一个新对象，这个对象同时拥有 o 的属性和 p 的属性
     * 如果 o 和 p 中有重名属性，使用 p 中的属性值
     */
    function union(o, p) {
        // 请实现函数体
    }
    /*
     * 返回一个新对象，这个对象拥有同时在 o 和 p 中出现的属性
     * 很像求 o 和 p 的交集，但 p 中属性的值被忽略
     */
    function intersection(o, p) {
        // 请实现函数体
    }
    /*
     * 返回一个数组，这个数组包含的是 o 中可枚举的自有属性的名字
     */
    function keys(o) {
        // 请实现函数体
    }


</script>
</body>
</html>